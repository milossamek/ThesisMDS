package com.MDS.ThesisMDS.backend.implementation.spaceFillingAlg;

import com.MDS.ThesisMDS.backend.implementation.interfaces.ILinearOrdering;
import com.MDS.ThesisMDS.backend.implementation.objects.LinearPoint;

import java.awt.*;
import java.util.ArrayList;
import java.util.Arrays;

//   The Z-order curve is generated by interleaving the bits of an offset.

public class ZCurve implements ILinearOrdering {

    private final int dimensions = 2; //working in 2D
    private int bits;

    public ZCurve() {
    }

    public ZCurve(int bits) {
        this.bits = bits;
    }


    private ArrayList<LinearPoint> calculateZOrder(Integer width, Integer height, Integer bits, Integer margin) {
        if (bits < 0 || bits > 64) {
            return null;
        }
        ZCurve curve = new ZCurve(bits);
        int n = 1 << bits;
        int cellSize = (width - 2 * margin) / (n);
        ArrayList<LinearPoint> returnArray = new ArrayList<>();

        returnArray.add(new LinearPoint(new Point(0, 0), new Point(margin + cellSize / 2, margin + cellSize / 2)));
        for (long i = 0; i < n * n; i++) {
            long[] point = curve.point(i);
            System.out.println(Arrays.toString(point));
            int x = (int) Math.round((double) point[0] / (n - 1) * (width - 2 * margin - cellSize) + margin) + cellSize / 2;
            int y = (int) Math.round((double) point[1] / (n - 1) * (height - 2 * margin - cellSize) + margin) + cellSize / 2;
            returnArray.add(new LinearPoint(new Point((int) point[0], (int) point[1]), new Point(x, y)));
        }

        return returnArray;
    }

    //The Z-order curve is generated by interleaving the bits of an offset.
    private long[] point(long index) {
        long[] returnPoint = new long[dimensions];
        Integer iWidth = bits * dimensions;
        for (int i = 0; i < iWidth; i++) {
            long actualPoint = bitRange(index, iWidth, i, i + 1) << ((iWidth - i - 1) / dimensions);
            returnPoint[i % dimensions] += actualPoint;
        }

        return transpose(returnPoint);
    }

    private long[] transpose(long[] array) {
        for (int i = 0; i < array.length / 2; i++) {
            long temp = array[i];
            array[i] = array[array.length - i - 1];
            array[array.length - i - 1] = temp;
        }

        return array;
    }

    private long bitRange(long x, Integer width, Integer start, Integer end) {
        return x >> (width - end) & Math.round(Math.pow(2, (end - start) - 1));
    }


    @Override
    public ArrayList<LinearPoint> calculatePoints(Integer width, Integer height, Integer bits, Integer margin) {
        return calculateZOrder(width, height, bits, margin);
    }
}
